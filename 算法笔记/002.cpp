/*描述
一张CT扫描的灰度图像可以用一个N*N（0 < N <= 100）的矩阵描述，矩阵上的每个点对应一个灰度值（整数），
其取值范围是0-255。我们假设给定的图像中有且只有一个肿瘤。在图上监测肿瘤的方法如下：如果某个点对应的灰度值小于等于50，
则这个点在肿瘤上，否则不在肿瘤上。我们把在肿瘤上的点的数目加起来，就得到了肿瘤在图上的面积。任何在肿瘤上的点，
如果它是图像的边界或者它的上下左右四个相邻点中至少有一个是非肿瘤上的点，则该点称为肿瘤的边界点。
肿瘤的边界点的个数称为肿瘤的周长。现在给定一个图像，要求计算其中的肿瘤的面积和周长。
输入
输入第一行包含一个正整数N（0 < N <= 100），表示图像的大小；接下来N行，每行包含图像的一行。
图像的一行用N个整数表示（所有整数大于等于0，小于等于255），两个整数之间用一个空格隔开。
输出
输出只有一行，该行包含两个正整数，分别为给定图像中肿瘤的面积和周长，用一个空格分开。
样例输入
6
99 99 99 99 99 99
99 99 99 50 99 99
99 99 49 49 50 51
99 50 20 25 52 99
40 50 99 99 99 99
99 99 99 99 99 99
样例输出
9 8
*/
//肿瘤检测


#include <iostream>
using namespace std;
 
int main()
{
	int sum = 0;
	int border = 0;
	int n;
 
	cin>>n;
 
	//动态创建二维数组
	int **area = new int* [n];
	for(int i=0; i<n; i++)
	{
		area[i] = new int[n];
	}
	//输入肿瘤分布
	for(int i=0; i<n; i++)
	{
		for(int j=0; j<n; j++)
		{
			cin>>area[i][j];
			if(area[i][j]<=50)
			{
				sum++;
			}
		}
	}
	//计算肿瘤边界,第一步计算数组边界是否有肿瘤边界，第二步除去数组边界计算肿瘤边界
	//计算第一行和最后一行的肿瘤边界数
	for(int i=0; i<n; i++)
	{
		if(area[0][i]<=50)
		{
			border++;
		}
 
		if(area[n-1][i]<=50)
		{
			border++;
		}
	}
	
	//计算第一列和最后一列的肿瘤边界数
	for(int i=1; i<n-1; i++)
	{
		if(area[i][0]<=50)
		{
			border++;
		}
 
		if(area[i][n-1]<=50)
		{
			border++;
		}
	}
	
	//边界计算第二步
	for(int i=1; i<n-1; i++)
	{
		for(int j=1; j<n-1; j++)
		{
			if(area[i][j]<=50)
			{
				//判断该点上下左右是否有大于50的像素点，有则表明是肿瘤边界
				bool t = area[i-1][j]>50 || area[i+1][j]>50 || area[i][j-1]>50 || area[i][j+1]>50;
				
				if(t)
				{
					border++;
				}
			}
		}
	}
 
	cout<<sum<<" "<<border<<endl;
 
	return 0;
}
