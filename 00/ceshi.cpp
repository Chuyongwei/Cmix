/*描述
约瑟夫问题：有ｎ只猴子，按顺时针方向围成一圈选大王（编号从１到ｎ），从第１号开始报数，一直数到ｍ，数到ｍ的猴子退出圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王，编程求输入ｎ，ｍ后，输出最后猴王的编号。

输入
每行是用空格分开的两个整数，第一个是 n, 第二个是 m ( 0 < m,n <=300)。最后一行是：

0 0

输出
对于每行输入数据（最后一行除外)，输出数据也是一行，即最后猴王的编号
样例输入
6 2
12 4
8 3
0 0
样例输出
5
1
7*/
/*
#include<iostream>
using namespace std;
int main() 
{
	int fun(int n,int m);
	int n,m;
	int a[10],i=0;
	while(1){
		cin >> n >> m;
		if(n==0&&m==0)
		break;
//		a = new int[i+1];
		a[i] = fun(n,m);
		i++;
	}
	int j;
	for(j=0;j<i;j++)
	{
		cout << a[j]<<endl; 
	}
}

int fun(int n,int m)//n个数，m报数,s剩余数，s1目前数 ,m2报数 
{
	int a[n];
	int s,s1=0,m2=1;
	s = n;
	for(int i = 0;i<n;++i)
	{
		a[i] = 0;
	}
	while(!(s==1))
	{
		while(1)
		{
		s1++;
		if(s1 > n ) s1 = 1;
			if(a[s1-1]==0)
			{
				m2++;
			}
			
			if(m2>m)
			{
				a[s1-1] = 1;
				m2 = 1;
				break;
			}	
		}
		s--;
	}
	for(int i = 0;i<n;i++)
	{
		if(a[i] == 0)
		return i+1;
	}
	
}
/*
/*鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。
鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图1）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”




我们假定多多在每个单位时间内，可以做下列四件事情中的一件：
1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。
现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。
例如在图2所示的花生田里，只有位于(2, 5), (3, 7), (4, 2), (5, 4)的植株下长有花生，个数分别为13, 7, 15, 9。沿着图示的路线，多多在21个单位时间内，最多可以采到37个花生。
输入
输入的第一行包括一个整数T，表示数据组数
每组输入的第一行包括三个整数，M, N和K，用空格隔开；表示花生田的大小为M * N（1 <= M, N <= 50），多多采花生的限定时间为K（0 <= K <= 1000）个单位时间。接下来的M行，每行包括N个非负整数，也用空格隔开；第i + 1行的第j个整数Pij（0 <= Pij <= 500）表示花生田里植株(i, j)下花生的数目，0表示该植株下没有花生。
输出
输出包括T行，每一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。
样例输入
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
样例输出
37*/
//#include<iostream>
//using namespace std;
//int main()
//{
//	char a[9][4];
//	cin <<"|"
//} 
//
//void one(0)

#include<iostream>
using namespace std;

int main()
{
	long a;
	int b[100],m;
	int i=0;
	int c;
	cin>>a;
	while(a>10)
	{
		i = 0;
		do
		{
			b[i] = a%10;
			a = a/10;
			i++;
		}while(a != 0);
		i--;
		do
		{
			a += b[i];
			i--;
		}while(i>=0);
	}
	c =a;
	cout<<c;
}


